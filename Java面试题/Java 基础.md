# `Java` 基础



## Java 和 C++ 主要有哪些区别？分别有什么优缺点？

Java和C++的主要区别有以下几点：

1. Java是平台无关的；C++是平台相关的
2. Java是通过GC实现自动内存管理；C++手动内存管理，使用new 申请内存、delete释放内存
3. Java的参数传递方式是值传递；C++有值传递、指针传递、引用传递
4. Java只支持单继承；C++既支持单继承，又支持多继承。
5. Java的底层控制能力弱，不能直接操作内存；C++底层控制能力强，可以直接操作内存和硬件。
6. Java是解释型语言，通过编译器编译成中间代码--字节码，再通过JVM对字节码进行解释执行；C++是编译型语言，直接通过编译器将源代码编译成对应平台的机器码。

Java的优缺点如下：

优点：

- 平台无关，一次编写到处运行
- 丰富的生态，各种库
- 丰富的社区支持，各种技术解决方案
- 垃圾回收器，自动内存管理，降低内存泄露的风险

缺点：

- 启动慢，需要靠JVM对字节码进行解释执行
- 会占用更的内存空间
- 性能没有C++好
- 底层控制能力弱



C++的优缺点如下：

优点：

- 性能高
- 能够直接操作内存、硬件
- 图形、音频库支持

缺点：

- 内存管理复杂，学习困难，容易造成内存泄露
- 平台相关，编写跨平台应用困难



## 如何理解面向对象和面向过程？

面向过程和面向对象是两种不同的思维方式。面向过程更加关注的是“怎么做”，更像流水线式作业，在解决问题时将问题分解成一系列步骤，按顺序执行这些步骤来解决问题。面向对象更加关注的是“谁来做”，更像是团队间协作，在解决问题时将问题分解成多个对象，每个对象负责特定的职责，通过对象间的协作来解决问题。



## **为什么Java不支持多继承？**

首先我们要直到支持多继承会怎么样，比如B、C两个类同时继承了A类，D类又同时继承了B、C类，这样就会导致A类的方法在D类中出现两次，这个现象叫做菱形继承，C++就支持多继承，为了解决菱形继承C++引入了虚继承，大大的提高了语言的复杂度。同时支持多继承会导致子类变得庞大，各个类之间的耦合增加。

---

之所以Java不支持多继承，主要是为了避免C++支持多继承导致的菱形继承问题。菱形继承：比如B、C两个类同时继承了A类，D类又同时继承了B、C类，这样就会导致A类的方法在D类中出现两次。其次不支持多继承可以保证语言的简洁性、避免多继承的歧义、降低代码的耦合、避免子类过于臃肿

---

Java 不支持多继承主要是为了避免菱形继承问题，同时保持语言的简洁性。 如果 A 类有一个方法，B 和 C 都重写了它，那么 D 继承时应该使用哪个版本？这会导致方法调用的二义性。不支持多继承的好处：保持语言的简洁性、避免歧义、降低耦合、防止子类过于臃肿（继承一些不必要的功能）；Java 通过接口实现了多继承的优点，同时避免了其缺点。



## **接口和抽象类的区别，如何选择？**

接口内部的默认修饰符是public abstract 而抽象类中的只要存在一个抽象方法即可；接口内部只可以存在抽象方法、默认方法、静态方法、私有方法，而抽象类没有限制；接口没有构造方法，抽象类有；至于如何选择的话，如果是为了复用代码就选择抽象类，是为了定义规范就选择接口。

---

接口和抽象类的主要区别在于：接口中的方法默认是 public abstract 的，只能定义常量（public static final），没有构造方法，一个类可以实现多个接口；而抽象类可以有抽象方法和具体方法，可以有实例变量和构造方法，但一个类只能继承一个抽象类。在选择上，如果需要代码复用、共享状态或者表达"是什么"的 is-a 关系，就用抽象类；如果是为了定义行为规范、需要多继承或者表达"能做什么"的 can-do 关系，就用接口。抽象类侧重于代码复用，接口侧重于定义规范，实际开发中接口使用更频繁因为更灵活。



## **如何理解Java中的多态？**

Java多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的结果。多态发生有三个必要的条件：继承或实现接口、重写父类或者接口的方法、父类的引用指向子类的对象。比如
```java
List<Integer> list = new ArrayList<>(); list.add(1);
```
虽然局部变量list的引用是List，但是实际执行的是ArrayList()类的add方法。多态提高了代码的扩展性和灵活性，用统一的接口操作不同的对象，降低了代码的耦合度。


## **Java中有了基本类型为什么还需要包装类？**

Java是基于面向对象的编程语言，更多的时候使用的还是对象而非基本数据类型，比如在使用集合的时候就不支持直接存储基本数据类型，这时候包装类就很有必要了。而且包装类提供了自动装箱和自动拆箱，使用起来也很方便。总结，无非就是包装类让基本类型具备了对象的特性，使其能够适应面向对象编程的各种场景。

---

Java 是面向对象的编程语言，更多场景需要使用对象而不是基本类型，比如集合（List、Map 等）只能存储对象，不能直接存储基本类型，这时候就必须用包装类。同时，包装类还提供了很多实用方法，比如类型转换、获取最大最小值等，并且支持自动装箱和拆箱，使用起来很方便。总的来说，包装类让基本类型具备了对象的特性，使其能够适应面向对象编程的各种场景。



## **为什么不能用浮点数表示金额？**

这主要是和浮点数的实现标准有关，浮点数采用IEEE754标准，为了用有限的内存空间表示更多的浮点数，IEEE754标准规定了一套浮点数的表示：符号位、指数为、尾数位，虽然可以使用有限的内存空间表示更多的浮点数，但是存储的并不是浮点数的精确值，而是一个近似值（非常接近），所以在金额这种对精确度要求极高的场景下是不能使用不精确的浮点数来表示的。

---

不能用浮点数表示金额主要是因为浮点数存在精度问题。浮点数采用 IEEE 754 标准，使用符号位、指数位和尾数位来表示，这种设计可以用有限的内存空间表示更大范围的数值，但代价是存储的是近似值而非精确值。比如 0.1 + 0.2 在计算机中并不等于 0.3，而是 0.30000000000000004，这种误差在金额计算中会累积放大，导致严重的错误。因此，在金额这种对精度要求极高的场景下，应该使用 BigDecimal 类来进行精确计算，它采用十进制表示，可以完全避免精度丢失的问题。



## **为什么不能用BigDecimal的equals方法做等值比较？**

因为BigDecimal的equals方法在比较时不仅会对值进行比较，而且还会对标度进行比较，比如0.1和0.01使用它的equals方法比较的结果为false。如果只想比较两个BigDecimal对象的值可以使用compareTo方法。

---

主要原因是equals方法不仅会比较数值本身，还会比较标度（scale）。举个例子，new BigDecimal("1.0")和new BigDecimal("1.00")，虽然它们的数值相等，但标度不同——前者标度是1，后者标度是2，所以用equals比较会返回false，这显然不符合我们的预期。正确的做法是使用compareTo方法，它只比较数值大小，不考虑标度。当compareTo返回0时，表示两个BigDecimal的数值相等。


## **BigDecimal(double)和BigDecimal(String)有什么区别？**

我们使用BigDecimal(0.3)创建出来的数值并不是正好等于0.3，而且标度也不等于1！这和浮点数的存储有关（IEEE754标准），而使用BigDecimal("0.3")创建出来的对象值是精确的，并且标度等于1.

---

这两个构造方法最大的区别在于精度问题。

使用BigDecimal(double)构造方法时，传入的double值本身就已经存在精度丢失了。比如new BigDecimal(0.3)，你可能以为得到的是0.3，但实际上得到的是0.30000000000000004，这是因为double类型遵循IEEE754标准，无法精确表示0.1。

而使用BigDecimal(String)构造方法，比如new BigDecimal("0.1")，得到的就是精确的0.1，标度也是符合预期的1。

所以在实际开发中，特别是涉及金融计算的场景，我们应该始终使用字符串构造方法来创建BigDecimal对象，避免精度问题。



## **为什么对Java中的负数取绝对值结果不一定是正数？**

这和Java中数值的存储有关，我们拿byte类型举例，byte类型的取值范围为[-128,127]因为0的出现我们发现负数的最小值，在byte的取值范围内没有与之对应的绝对值。我们在计算绝对值时只需要把类型向上提升在取绝对值就可以了。比如 :

```java
byte b = -128;
int abs = Math.abs((int)b);
```
---
这个问题的根源在于Java整数类型的取值范围是不对称的。

我们以byte类型为例，它的取值范围是[-128, 127]。你会发现负数可以表示到-128，但正数只能表示到127。这是因为在二进制补码表示法中，0占用了一个正数的位置，导致负数比正数多一个。

所以当我们对-128取绝对值时，理论上应该得到128，但128超出了byte的最大值127，就会发生溢出，结果还是-128。这个问题在所有Java整数类型中都存在：
```java
byte: -128的绝对值还是-128
int: -2147483648的绝对值还是-2147483648
```

解决方法是在取绝对值之前，先将类型向上转型。比如：
```java
byte b = -128;
int abs = Math.abs((int)b);  // 结果是128，正确
```

或者更安全的做法是，在业务逻辑中先判断是否是最小值，避免这种边界情况的出现。


## **String、StringBuilder和StringBuffer的区别?**

String是不可变的，StringBuilder和StringBuffer是可变的；String和StringBuffer是线程安全的，StringBuilder是线程不安全的；StringBuilder的性能优于StringBuffer；

---
主要从三个角度来说：可变性、线程安全性和性能。

首先是可变性。String是不可变的，一旦创建就不能修改，每次对String的操作实际上都会创建新的对象。而StringBuilder和StringBuffer是可变的，可以在原对象上进行修改，不会产生新对象。

其次是线程安全性。StringBuffer是线程安全的，它的方法都加了synchronized关键字，所以在多线程环境下可以安全使用。而String不可变，这种不可变性天然保证了线程安全。StringBuilder是线程不安全的，它没有同步机制，不适合在多线程环境下使用。

最后是性能。正因为StringBuffer的方法都加了同步锁，所以性能相对较低。StringBuilder没有同步开销，性能最好。String由于不可变，频繁操作会产生大量临时对象，性能最差。

使用建议：

单线程环境下频繁字符串拼接，用StringBuilder
多线程环境下需要字符串拼接，用StringBuffer
字符串内容不变或偶尔拼接，用String就够了

## **String为什么设计成不可变的？**

缓存：线程池的需要，只有String不可变了缓存才有意义，不然进行缓存之后如果一个引用修改了字符串常量池中的某个字符串，其他指向这个字符串的引用的字符串的内容也会发生改变

安全性：不可变字符让我们可以相信字符串的内容

线程安全：不可变天然保证了线程安全

hashcode缓存：由于字符串内容不可变，保证了根据字符串内容计算出的hashcode计算出的hash值不变，从而进行缓存

性能：缓存、hashcode缓存提高了String类的性能

---
String设计成不可变主要是出于以下几个方面的考虑：

第一，支持字符串常量池。Java中有字符串常量池的概念，多个引用可以指向池中的同一个字符串对象。如果String是可变的，那么一个引用修改了字符串内容，其他引用指向的内容也会跟着变化，这显然是不可接受的。只有不可变，字符串常量池才有意义，才能实现字符串的复用，节省内存。

第二，保证安全性。String经常被用作参数传递，比如网络连接、文件路径、数据库连接等敏感操作。如果String是可变的，在传递过程中内容可能被篡改，会带来严重的安全隐患。不可变性让我们可以放心地传递和使用字符串。

第三，天然的线程安全。因为String对象创建后内容不能改变，所以多个线程同时访问同一个String对象时，不需要任何同步机制，天然就是线程安全的。

第四，支持hashCode缓存。String类中有一个hash字段用来缓存hashCode值。因为内容不可变，所以hashCode只需要计算一次就可以缓存起来，后续直接使用。这对于String作为HashMap的key等场景非常重要，能显著提升性能。

第五，整体性能优化。正是因为有了字符串常量池和hashCode缓存这些机制，String类在实际使用中的性能表现非常好。



## **String str=new String("zhc")创建了几个对象？**

分两种情况，如果字符创常量池中存在字符串“zhc”，那么就只会在堆中创建一个对象。如果不存在那么会在字符串常量池和堆中分别创建一个对象。



## **String a = "ab"; String b = "a" + "b"; a == b 吗？**

String b = "a" + "b"; 在编译时会优化为 "ab",进而会被字符串常量池缓存，String a也指向字符串常量池中的"ab"字符串。== 比较的是两个对象的引用地址是否相同，所以 a==b为true；



## **String有长度限制吗？是多少？**

有限制；编译期和运行期花不一样，编译期为65535；运行期为 java.lang.Integer.MAX_VALUE 也就是 2^31 - 1



## **RPC接口返回中，使用基本类型还是包装类？**

推荐使用包装类；如果RPC接口中的某个字段返回了0或者-1这种值你不直到是调用成功返回的还是失败了返回的会产生歧义，虽然接口的其他字段会清晰的表达调用是否成功，但是使用包装类返回null，会尽可能的减少歧义。



## **常见的字符编码有哪些？有什么区别？**

常见的字符编码表有unicode、utf-8、gbk等，gbk是专门为中文编码诞生的编码表，它使用更少的空间2个字节来为一个汉字进行编码，虽然utf-8支持的字符更多，但是它占用的空间也更多，utf-8中使用三个字节为一个汉字进行编码。



## **说几个常见的语法糖？**(补充)

try with resources 使用try(资源){}资源只要实现了closeable接口，代码执行try完毕会自动调用close释放资源，而不需要收到调用close()进行资源的关闭。

基本数据类型的自动装箱和自动拆箱。

lambda表达式

for-each

...



## **Lambda表达式是如何实现的？**

Lambda表达式是通过编译时将lambda转换成api调用实现的，底层为这个转换提供了api支持





## **什么是泛型？有什么好处？**

