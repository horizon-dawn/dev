# Java 基础面试题

## Java 和 C++ 主要有哪些区别？分别有什么优缺点？

Java 和 C++ 的主要区别体现在平台依赖性、内存管理、参数传递、继承方式、底层控制能力和执行方式等方面。

Java 是平台无关的语言，通过 JVM 实现"一次编写，到处运行"；而 C++ 是平台相关的，需要针对不同平台编译。在内存管理上，Java 通过 GC 实现自动内存管理，C++ 则需要手动使用 new/delete 管理内存。参数传递方面，Java 只支持值传递，C++ 支持值传递、指针传递和引用传递。继承方式上，Java 只支持单继承，C++ 既支持单继承又支持多继承。底层控制能力方面，Java 不能直接操作内存，C++ 可以直接操作内存和硬件。执行方式上，Java 是解释型语言，通过编译器编译成字节码再由 JVM 解释执行；C++ 是编译型语言，直接编译成机器码。

Java 的优点包括：平台无关性强、生态丰富、社区支持完善、垃圾回收器降低内存泄露风险。缺点是：启动速度较慢、内存占用较大、性能不如 C++、底层控制能力弱。

C++ 的优点包括：性能高效、能直接操作内存和硬件、图形和音频库支持丰富。缺点是：内存管理复杂、学习曲线陡峭、容易造成内存泄露、跨平台开发困难。

---

## 如何理解面向对象和面向过程？

面向过程和面向对象是两种不同的编程思维方式。

面向过程更关注"怎么做"，类似流水线式作业。在解决问题时，将问题分解成一系列步骤，按顺序执行这些步骤来完成任务。

面向对象更关注"谁来做"，类似团队协作。在解决问题时，将问题分解成多个对象，每个对象负责特定的职责，通过对象间的协作来解决问题。

---

## 为什么 Java 不支持多继承？

Java 不支持多继承主要是为了避免菱形继承问题，同时保持语言的简洁性。

菱形继承是指：当 B、C 两个类同时继承了 A 类，D 类又同时继承了 B、C 类时，A 类的方法在 D 类中会出现两次。如果 A 类有一个方法，B 和 C 都重写了它，那么 D 继承时应该使用哪个版本？这会导致方法调用的二义性。C++ 支持多继承，为了解决菱形继承问题引入了虚继承，大大提高了语言的复杂度。

不支持多继承的好处包括：保持语言的简洁性、避免方法调用的歧义、降低类之间的耦合、防止子类过于臃肿（继承一些不必要的功能）。

Java 通过接口实现了多继承的优点，同时避免了其缺点。

---

## 接口和抽象类的区别，如何选择？

接口和抽象类的主要区别在于：

接口中的方法默认是 public abstract 的，只能定义常量（public static final），没有构造方法，一个类可以实现多个接口。

抽象类可以有抽象方法和具体方法，可以有实例变量和构造方法，但一个类只能继承一个抽象类。

在选择上，如果需要代码复用、共享状态或者表达"是什么"的 is-a 关系，就用抽象类；如果是为了定义行为规范、需要多继承或者表达"能做什么"的 can-do 关系，就用接口。

抽象类侧重于代码复用，接口侧重于定义规范。实际开发中接口使用更频繁，因为更灵活。

---

## 如何理解 Java 中的多态？

Java 多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的结果。

多态发生有三个必要条件：继承或实现接口、重写父类或接口的方法、父类的引用指向子类的对象。

举个例子：

```java
List<Integer> list = new ArrayList<>();
list.add(1);
```

虽然局部变量 list 的引用类型是 List，但实际执行的是 ArrayList 类的 add 方法。

多态提高了代码的扩展性和灵活性，可以用统一的接口操作不同的对象，降低了代码的耦合度。

---

## Java 中有了基本类型为什么还需要包装类？

Java 是面向对象的编程语言，更多场景需要使用对象而不是基本类型。

比如集合（List、Map 等）只能存储对象，不能直接存储基本类型，这时候就必须用包装类。同时，包装类还提供了很多实用方法，比如类型转换、获取最大最小值等，并且支持自动装箱和拆箱，使用起来很方便。

总的来说，包装类让基本类型具备了对象的特性，使其能够适应面向对象编程的各种场景。

---

## 为什么不能用浮点数表示金额？

不能用浮点数表示金额主要是因为浮点数存在精度问题。

浮点数采用 IEEE 754 标准，使用符号位、指数位和尾数位来表示。这种设计可以用有限的内存空间表示更大范围的数值，但代价是存储的是近似值而非精确值。

比如 0.1 + 0.2 在计算机中并不等于 0.3，而是 0.30000000000000004，这种误差在金额计算中会累积放大，导致严重的错误。

因此，在金额这种对精度要求极高的场景下，应该使用 BigDecimal 类来进行精确计算，它采用十进制表示，可以完全避免精度丢失的问题。

---

## 为什么不能用 BigDecimal 的 equals 方法做等值比较？

主要原因是 equals 方法不仅会比较数值本身，还会比较标度（scale）。

举个例子，new BigDecimal("1.0") 和 new BigDecimal("1.00")，虽然它们的数值相等，但标度不同——前者标度是 1，后者标度是 2，所以用 equals 比较会返回 false，这显然不符合我们的预期。

正确的做法是使用 compareTo 方法，它只比较数值大小，不考虑标度。当 compareTo 返回 0 时，表示两个 BigDecimal 的数值相等。

---

## BigDecimal(double) 和 BigDecimal(String) 有什么区别？

这两个构造方法最大的区别在于精度问题。

使用 BigDecimal(double) 构造方法时，传入的 double 值本身就已经存在精度丢失了。比如 new BigDecimal(0.3)，你可能以为得到的是 0.3，但实际上得到的是 0.30000000000000004，这是因为 double 类型遵循 IEEE 754 标准，无法精确表示 0.3。

而使用 BigDecimal(String) 构造方法，比如 new BigDecimal("0.3")，得到的就是精确的 0.3，标度也是符合预期的 1。

所以在实际开发中，特别是涉及金融计算的场景，我们应该始终使用字符串构造方法来创建 BigDecimal 对象，避免精度问题。

---

## 为什么对 Java 中的负数取绝对值结果不一定是正数？

这个问题的根源在于 Java 整数类型的取值范围是不对称的。

以 byte 类型为例，它的取值范围是 [-128, 127]。你会发现负数可以表示到 -128，但正数只能表示到 127。这是因为在二进制补码表示法中，0 占用了一个正数的位置，导致负数比正数多一个。

所以当我们对 -128 取绝对值时，理论上应该得到 128，但 128 超出了 byte 的最大值 127，就会发生溢出，结果还是 -128。这个问题在所有 Java 整数类型中都存在。

解决方法是在取绝对值之前，先将类型向上转型：

```java
byte b = -128;
int abs = Math.abs((int)b);  // 结果是 128，正确
```

或者更安全的做法是，在业务逻辑中先判断是否是最小值，避免这种边界情况的出现。

---

## String、StringBuilder 和 StringBuffer 的区别？

主要从三个角度来说：可变性、线程安全性和性能。

首先是可变性。String 是不可变的，一旦创建就不能修改，每次对 String 的操作实际上都会创建新的对象。而 StringBuilder 和 StringBuffer 是可变的，可以在原对象上进行修改，不会产生新对象。

其次是线程安全性。StringBuffer 是线程安全的，它的方法都加了 synchronized 关键字，所以在多线程环境下可以安全使用。而 String 不可变，这种不可变性天然保证了线程安全。StringBuilder 是线程不安全的，它没有同步机制，不适合在多线程环境下使用。

最后是性能。正因为 StringBuffer 的方法都加了同步锁，所以性能相对较低。StringBuilder 没有同步开销，性能最好。String 由于不可变，频繁操作会产生大量临时对象，性能最差。

使用建议：单线程环境下频繁字符串拼接用 StringBuilder，多线程环境下需要字符串拼接用 StringBuffer，字符串内容不变或偶尔拼接用 String 就够了。

---

## String 为什么设计成不可变的？

String 设计成不可变主要是出于以下几个方面的考虑：

第一，支持字符串常量池。Java 中有字符串常量池的概念，多个引用可以指向池中的同一个字符串对象。如果 String 是可变的，那么一个引用修改了字符串内容，其他引用指向的内容也会跟着变化，这显然是不可接受的。只有不可变，字符串常量池才有意义，才能实现字符串的复用，节省内存。

第二，保证安全性。String 经常被用作参数传递，比如网络连接、文件路径、数据库连接等敏感操作。如果 String 是可变的，在传递过程中内容可能被篡改，会带来严重的安全隐患。不可变性让我们可以放心地传递和使用字符串。

第三，天然的线程安全。因为 String 对象创建后内容不能改变，所以多个线程同时访问同一个 String 对象时，不需要任何同步机制，天然就是线程安全的。

第四，支持 hashCode 缓存。String 类中有一个 hash 字段用来缓存 hashCode 值。因为内容不可变，所以 hashCode 只需要计算一次就可以缓存起来，后续直接使用。这对于 String 作为 HashMap 的 key 等场景非常重要，能显著提升性能。

第五，整体性能优化。正是因为有了字符串常量池和 hashCode 缓存这些机制，String 类在实际使用中的性能表现非常好。

---

## String str = new String("zhc") 创建了几个对象？

分两种情况：

情况一：字符串常量池中已经存在 "zhc"

这种情况下只会创建 1 个对象，就是通过 new 关键字在堆内存中创建的 String 对象。字符串常量池中的 "zhc" 已经存在，不需要再创建。

情况二：字符串常量池中不存在 "zhc"

这种情况下会创建 2 个对象：第一个对象是在字符串常量池中创建字符串字面量 "zhc"，第二个对象是通过 new 关键字在堆内存中创建 String 对象。

需要注意的是，这两个对象是不同的。堆中的 String 对象会引用字符串常量池中的 "zhc"，但它们的内存地址是不同的。

---

## String a = "ab"; String b = "a" + "b"; a == b 吗？

答案是 true，a == b。

这里触发了 Java 编译器非常重要的优化——常量折叠（Constant Folding）。

当我们写 String b = "a" + "b" 时，因为 "a" 和 "b" 都是字符串字面量常量，编译器在编译阶段就会将这个表达式优化为 String b = "ab"。也就是说，编译后的字节码中，这两行代码实际上是一样的。

由于都是字符串字面量，它们都会被放入字符串常量池中。根据字符串常量池的机制，相同内容的字符串只会存在一份，所以 a 和 b 实际上指向的是常量池中同一个 "ab" 对象。

因为 == 比较的是对象的引用地址，而 a 和 b 指向同一个对象，所以 a == b 返回 true。

需要注意的对比情况：如果涉及变量拼接，结果就不同了：

```java
String s1 = "a";
String s2 = "b";
String c = s1 + s2;  // 变量拼接，会在堆中创建新对象
String a = "ab";
System.out.println(a == c);  // false，因为 c 指向堆，a 指向常量池
```

这是因为变量拼接在编译期无法确定值，只能在运行时通过 StringBuilder 来完成，会创建新的对象。

---

## String 有长度限制吗？是多少？

String 是有长度限制的，而且在编译期和运行期的限制是不一样的。

编译期限制：65534 字符

在编译期，字符串字面量的长度受到 class 文件格式的限制。在 class 文件的常量池中，字符串常量使用 CONSTANT_Utf8_info 结构存储，其中长度字段是 u2 类型，占 2 个字节，所以理论上最大值是 2^16-1 = 65535。如果你在代码中写一个超过这个长度的字符串字面量，编译器会直接报错："constant string too long"。

运行期限制：2^31-1 字符

在运行期，String 的长度限制取决于 String 类的实现。String 内部使用 char 数组（Java 9 之后是 byte 数组）来存储字符，而数组的最大长度是 Integer.MAX_VALUE，也就是 2^31-1 = 2147483647。

所以理论上运行时可以创建一个包含约 21 亿个字符的 String 对象，但实际上会受到 JVM 堆内存大小的限制。

---

## RPC 接口返回中，使用基本类型还是包装类？

推荐使用包装类，主要有以下几个原因：

第一，避免语义歧义。基本类型都有默认值，比如 int 默认是 0，boolean 默认是 false。当 RPC 接口返回 0 或 false 时，你无法判断这是业务逻辑正常返回的值，还是因为字段未赋值而产生的默认值。

第二，明确表达"无值"状态。包装类可以用 null 来表示"无值"或"未知"的状态，这在很多业务场景下是必要的。比如：用户未填写某个可选字段、数据库中该字段为 NULL、远程调用失败未获取到数据。这些情况用 null 表示比用默认值更清晰、更准确。

---

## 常见的字符编码有哪些？有什么区别？

常见的字符编码主要有 ASCII、Unicode、UTF-8、GBK 等，它们各有特点：

ASCII 编码：最早的字符编码，使用 1 个字节（7 位）编码，只能表示 128 个字符，主要是英文字母、数字和一些符号。它是其他编码的基础。

Unicode 编码：这是一个字符集标准，不是具体的编码实现。它为世界上几乎所有的字符都分配了一个唯一的编号（码点），解决了不同编码之间的兼容问题。但 Unicode 只是定义了字符和编号的对应关系，具体如何存储需要由 UTF-8、UTF-16 等编码方式来实现。

UTF-8 编码：Unicode 的一种变长编码实现，使用 1 到 4 个字节来编码字符。ASCII 字符占 1 个字节，常用汉字占 3 个字节，生僻字或 emoji 占 4 个字节。UTF-8 的优点是兼容 ASCII，节省存储空间，是目前互联网上使用最广泛的编码方式。

UTF-16 编码：Unicode 的另一种编码实现，使用 2 个或 4 个字节。Java 内部就是使用 UTF-16 来存储字符的。它的优点是大部分常用字符都是 2 个字节，访问效率高，但不兼容 ASCII。

GBK 编码：专门为中文设计的编码，使用 2 个字节编码一个汉字。相比 UTF-8 的 3 个字节，GBK 存储中文更节省空间。但它只支持中文和少量其他字符，不如 UTF-8 通用。

---

## 说几个常见的语法糖？

1. 自动装箱和拆箱（Autoboxing/Unboxing）

基本类型和包装类之间可以自动转换，编译器会自动调用 valueOf() 和 xxxValue() 方法：

```java
Integer i = 10;  // 自动装箱，等价于 Integer.valueOf(10)
int j = i;       // 自动拆箱，等价于 i.intValue()
```

2. try-with-resources

自动资源管理，只要资源实现了 AutoCloseable 或 Closeable 接口，try 执行完毕后会自动调用 close() 方法释放资源，不需要手动关闭：

```java
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // 使用资源
} // 自动调用 fis.close()
```

3. 增强 for 循环（for-each）

简化了集合和数组的遍历，编译器会将其转换为迭代器或普通 for 循环：

```java
for (String item : list) {
    System.out.println(item);
}
```

4. 泛型

编译时提供类型检查，运行时会进行类型擦除：

```java
List<String> list = new ArrayList<>();  // 编译后泛型信息会被擦除
```

5. 可变参数（Varargs）

方法可以接收不定数量的参数，编译器会将其转换为数组：

```java
public void method(String... args) {}  // 实际是 String[] args
```

6. Lambda 表达式

简化了匿名内部类的写法，编译器会将其转换为函数式接口的实现：

```java
list.forEach(item -> System.out.println(item));
```

7. switch 支持 String 和枚举

早期 switch 只支持整型，现在支持 String 和枚举，编译器会转换为 if-else 或整型 switch。

8. 枚举类型

看起来是特殊的类型，实际上编译后会生成继承自 Enum 的类。

---

## Lambda 表达式是如何实现的？

Lambda 表达式的实现比较复杂，它并不是简单的语法糖，而是通过 invokedynamic 指令和方法句柄来实现的。

实现机制：

第一步：编译时转换

编译器在编译 Lambda 表达式时，会做两件事：将 Lambda 表达式的代码体生成为一个私有静态方法（或实例方法），在 Lambda 表达式的位置生成一个 invokedynamic 指令。

举个例子：

```java
List<String> list = Arrays.asList("a", "b", "c");
list.forEach(s -> System.out.println(s));
```

编译后，Lambda 体会被转换成类似这样的私有方法：

```java
private static void lambda$main$0(String s) {
    System.out.println(s);
}
```

第二步：运行时动态链接

当程序第一次执行到 Lambda 表达式时，invokedynamic 指令会调用 Java 提供的 LambdaMetafactory 工厂类，动态生成一个实现了函数式接口的内部类，这个内部类会调用前面生成的私有方法。

为什么不用匿名内部类？

使用匿名内部类有明显的缺点：每个 Lambda 都会生成一个 class 文件，增加类加载开销；性能较差，启动速度慢。

使用 invokedynamic 的优势：延迟绑定，只在第一次使用时才生成实现类；可以进行更多的运行时优化；减少了 class 文件的数量。
