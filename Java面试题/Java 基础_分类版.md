# Java 基础面试题（按知识点分类）

---

## 一、Java 语言特性

### 1.1 Java 和 C++ 主要有哪些区别？分别有什么优缺点？

Java 是平台无关的语言，通过 JVM 实现"一次编写，到处运行"；而 C++ 是平台相关的，需要针对不同平台编译。

在内存管理上，Java 通过 GC 实现自动内存管理，C++ 则需要手动使用 new/delete 管理内存。

参数传递方面，Java 只支持值传递，C++ 支持值传递、指针传递和引用传递。

继承方式上，Java 只支持单继承，C++ 既支持单继承又支持多继承。

底层控制能力方面，Java 不能直接操作内存，C++ 可以直接操作内存和硬件。

执行方式上，Java 是解释型语言，通过编译器编译成字节码再由 JVM 解释执行；C++ 是编译型语言，直接编译成机器码。

Java 的优点包括平台无关性强、生态丰富、社区支持完善、垃圾回收器降低内存泄露风险。缺点是：启动速度较慢、内存占用较大、性能不如 C++、底层控制能力弱。

C++ 的优点包括性能高效、能直接操作内存和硬件、图形和音频库支持丰富。缺点是：内存管理复杂、学习曲线陡峭、容易造成内存泄露、跨平台开发困难。

---

### 1.2 如何理解面向对象和面向过程？

面向过程和面向对象是两种不同的编程思维方式。

面向过程更关注"怎么做"，类似流水线式作业。在解决问题时，将问题分解成一系列步骤，按顺序执行这些步骤来完成任务。

面向对象更关注"谁来做"，类似团队协作。在解决问题时，将问题分解成多个对象，每个对象负责特定的职责，通过对象间的协作来解决问题。

---

### 1.3 Java 是值传递还是引用传递？

Java 只有值传递，没有引用传递。这是一个容易混淆的概念，需要分情况理解：

**对于基本数据类型**：传递的是数值的副本。方法内对参数的修改不会影响原变量。比如传入一个 int 类型的变量，方法内修改这个参数，外部的原变量不会改变。

**对于引用数据类型**：传递的是引用地址的副本。这里容易产生误解，看起来像引用传递，但本质上传递的是引用值的拷贝。具体来说：

- 方法接收到的是对象引用的一个副本，这个副本和原引用指向同一个对象
- 通过这个副本可以修改对象的内容，所以外部能看到对象内部状态的变化
- 但如果在方法内给参数重新赋值（指向新对象），不会影响外部的原引用

举个例子：

```java
public void test(StringBuilder sb) {
    sb.append("world");  // 修改对象内容，外部可见
    sb = new StringBuilder("new");  // 重新赋值，外部不可见
}

StringBuilder sb = new StringBuilder("hello");
test(sb);
System.out.println(sb);  // 输出 "helloworld"，不是 "new"
```

这个例子说明：传递的是引用的副本，而不是引用本身。如果是真正的引用传递，重新赋值应该会影响外部变量。

总结：Java 永远是值传递，只不过传递的"值"可能是基本类型的数值，也可能是引用类型的地址值。

---


## 二、面向对象

### 2.1 为什么 Java 不支持多继承？

Java 不支持多继承主要是为了避免**菱形继承**问题，同时保持**语言的简洁性**。

菱形继承是指：当 B、C 两个类同时继承了 A 类，D 类又同时继承了 B、C 类时，A 类的方法在 D 类中会出现两次。如果 A 类有一个方法，B 和 C 都重写了它，那么 D 继承时应该使用哪个版本？这会导致方法调用的二义性。C++ 支持多继承，为了解决菱形继承问题引入了虚继承，大大提高了语言的复杂度。

不支持多继承的好处包括：保持语言的简洁性、避免方法调用的歧义、降低类之间的耦合、防止子类过于臃肿（继承一些不必要的功能）。

---

### 2.2 接口和抽象类的区别，如何选择？

接口和抽象类的主要区别在于：

接口中的方法默认是 public abstract 的，只能定义常量（public static final），没有构造方法，一个类可以实现多个接口。

抽象类可以有抽象方法和具体方法，可以有实例变量和构造方法，但一个类只能继承一个抽象类。

在选择上，如果需要代码复用、共享状态或者表达"是什么"的 is-a 关系，就用抽象类；如果是为了定义行为规范、需要多继承或者表达"能做什么"的 can-do 关系，就用接口。

抽象类侧重于代码复用，接口侧重于定义规范。实际开发中接口使用更频繁，因为更灵活。

---

### 2.3 如何理解 Java 中的多态？

Java 多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的结果。

多态发生有三个必要条件：继承或实现接口、重写父类或接口的方法、父类的引用指向子类的对象。

举个例子：

```java
List<Integer> list = new ArrayList<>();
list.add(1);
```

虽然局部变量 list 的引用类型是 List，但实际执行的是 ArrayList 类的 add 方法。

多态提高了代码的扩展性和灵活性，可以用统一的接口操作不同的对象，降低了代码的耦合度。

---


## 三、基本类型与包装类

### 3.1 Java 中有了基本类型为什么还需要包装类？

Java 是面向对象的编程语言，更多场景需要使用对象而不是基本类型。

比如集合（List、Map 等）只能存储对象，不能直接存储基本类型，这时候就必须用包装类。同时，包装类还提供了很多实用方法，比如类型转换、获取最大最小值等，并且支持自动装箱和拆箱，使用起来很方便。

总的来说，包装类让基本类型具备了对象的特性，使其能够适应面向对象编程的各种场景。

---

### 3.2 为什么不能用浮点数表示金额？

不能用浮点数表示金额主要是因为浮点数存在精度问题。

浮点数采用 IEEE 754 标准，使用符号位、指数位和尾数位来表示。这种设计可以用有限的内存空间表示更大范围的数值，但代价是存储的是近似值而非精确值。

比如 0.1 + 0.2 在计算机中并不等于 0.3，而是 0.30000000000000004，这种误差在金额计算中会累积放大，导致严重的错误。

因此，在金额这种对精度要求极高的场景下，应该使用 BigDecimal 类来进行精确计算，它采用十进制表示，可以完全避免精度丢失的问题。

---

### 3.3 为什么不能用 BigDecimal 的 equals 方法做等值比较？

主要原因是 equals 方法不仅会比较数值本身，还会比较标度（scale）。

举个例子，new BigDecimal("1.0") 和 new BigDecimal("1.00")，虽然它们的数值相等，但标度不同——前者标度是 1，后者标度是 2，所以用 equals 比较会返回 false，这显然不符合我们的预期。

正确的做法是使用 compareTo 方法，它只比较数值大小，不考虑标度。当 compareTo 返回 0 时，表示两个 BigDecimal 的数值相等。

---

### 3.4 BigDecimal(double) 和 BigDecimal(String) 有什么区别？

这两个构造方法最大的区别在于精度问题。

使用 BigDecimal(double) 构造方法时，传入的 double 值本身就已经存在精度丢失了。比如 new BigDecimal(0.3)，你可能以为得到的是 0.3，但实际上得到的是 0.30000000000000004，这是因为 double 类型遵循 IEEE 754 标准，无法精确表示 0.3。

而使用 BigDecimal(String) 构造方法，比如 new BigDecimal("0.3")，得到的就是精确的 0.3，标度也是符合预期的 1。

所以在实际开发中，特别是涉及金融计算的场景，我们应该始终使用字符串构造方法来创建 BigDecimal 对象，避免精度问题。

---

### 3.5 为什么对 Java 中的负数取绝对值结果不一定是正数？

这个问题的根源在于 Java 整数类型的取值范围是不对称的。

以 byte 类型为例，它的取值范围是 [-128, 127]。你会发现负数可以表示到 -128，但正数只能表示到 127。这是因为在二进制补码表示法中，0 占用了一个正数的位置，导致负数比正数多一个。

所以当我们对 -128 取绝对值时，理论上应该得到 128，但 128 超出了 byte 的最大值 127，就会发生溢出，结果还是 -128。这个问题在所有 Java 整数类型中都存在。

解决方法是在取绝对值之前，先将类型向上转型：

```java
byte b = -128;
int abs = Math.abs((int)b);  // 结果是 128，正确
```

或者更安全的做法是，在业务逻辑中先判断是否是最小值，避免这种边界情况的出现。

---

### 3.6 RPC 接口返回中，使用基本类型还是包装类？

推荐使用包装类，主要有以下几个原因：

第一，避免语义歧义。基本类型都有默认值，比如 int 默认是 0，boolean 默认是 false。当 RPC 接口返回 0 或 false 时，你无法判断这是业务逻辑正常返回的值，还是因为字段未赋值而产生的默认值。

第二，明确表达"无值"状态。包装类可以用 null 来表示"无值"或"未知"的状态，这在很多业务场景下是必要的。比如：用户未填写某个可选字段、数据库中该字段为 NULL、远程调用失败未获取到数据。这些情况用 null 表示比用默认值更清晰、更准确。

---

### 3.7 char 能存储中文吗？

char 可以存储中文，但只能存储大部分常用中文字符。

Java 中的 char 类型使用 2 个字节（16 位）来存储一个字符，采用 UTF-16 编码。这意味着 char 可以表示 Unicode 基本多文种平面（BMP）中的字符，范围是 U+0000 到 U+FFFF，共 65536 个字符。大部分常用的中文汉字都在这个范围内，所以可以正常存储。

举个例子：

```java
char c1 = '中';
char c2 = '文';
System.out.println(c1 + " " + c2);  // 输出：中 文
```

但需要注意的是，一些生僻字、emoji 表情符号等超出了 BMP 范围，它们的 Unicode 码点大于 U+FFFF，需要用两个 char（即一个代理对）来表示，单个 char 无法存储。比如 emoji "😀" 的码点是 U+1F600，超出了 char 的表示范围。

所以准确的说法是：char 可以存储 Unicode BMP 范围内的字符，包括绝大多数常用中文，但无法存储超出这个范围的生僻字和特殊符号。如果需要处理所有 Unicode 字符，应该使用 String 类型。

---


## 四、String 类

### 4.1 String、StringBuilder 和 StringBuffer 的区别？

主要从三个角度来说：可变性、线程安全性和性能。

首先是可变性。String 是不可变的，一旦创建就不能修改，每次对 String 的操作实际上都会创建新的对象。而 StringBuilder 和 StringBuffer 是可变的，可以在原对象上进行修改，不会产生新对象。

其次是线程安全性。StringBuffer 是线程安全的，它的方法都加了 synchronized 关键字，所以在多线程环境下可以安全使用。而 String 不可变，这种不可变性天然保证了线程安全。StringBuilder 是线程不安全的，它没有同步机制，不适合在多线程环境下使用。

最后是性能。正因为 StringBuffer 的方法都加了同步锁，所以性能相对较低。StringBuilder 没有同步开销，性能最好。String 由于不可变，频繁操作会产生大量临时对象，性能最差。

使用建议：单线程环境下频繁字符串拼接用 StringBuilder，多线程环境下需要字符串拼接用 StringBuffer，字符串内容不变或偶尔拼接用 String 就够了。

---

### 4.2 String 为什么设计成不可变的？

String 设计成不可变主要是出于以下几个方面的考虑：

第一，支持字符串常量池。Java 中有字符串常量池的概念，多个引用可以指向池中的同一个字符串对象。如果 String 是可变的，那么一个引用修改了字符串内容，其他引用指向的内容也会跟着变化，这显然是不可接受的。只有不可变，字符串常量池才有意义，才能实现字符串的复用，节省内存。

第二，保证安全性。String 经常被用作参数传递，比如网络连接、文件路径、数据库连接等敏感操作。如果 String 是可变的，在传递过程中内容可能被篡改，会带来严重的安全隐患。不可变性让我们可以放心地传递和使用字符串。

第三，天然的线程安全。因为 String 对象创建后内容不能改变，所以多个线程同时访问同一个 String 对象时，不需要任何同步机制，天然就是线程安全的。

第四，支持 hashCode 缓存。String 类中有一个 hash 字段用来缓存 hashCode 值。因为内容不可变，所以 hashCode 只需要计算一次就可以缓存起来，后续直接使用。这对于 String 作为 HashMap 的 key 等场景非常重要，能显著提升性能。

第五，整体性能优化。正是因为有了字符串常量池和 hashCode 缓存这些机制，String 类在实际使用中的性能表现非常好。

---

### 4.3 String str = new String("zhc") 创建了几个对象？

分两种情况：

情况一：字符串常量池中已经存在 "zhc"

这种情况下只会创建 1 个对象，就是通过 new 关键字在堆内存中创建的 String 对象。字符串常量池中的 "zhc" 已经存在，不需要再创建。

情况二：字符串常量池中不存在 "zhc"

这种情况下会创建 2 个对象：第一个对象是在字符串常量池中创建字符串字面量 "zhc"，第二个对象是通过 new 关键字在堆内存中创建 String 对象。

需要注意的是，这两个对象是不同的。堆中的 String 对象会引用字符串常量池中的 "zhc"，但它们的内存地址是不同的。

---

### 4.4 String a = "ab"; String b = "a" + "b"; a == b 吗？

答案是 true，a == b。

这里触发了 Java 编译器非常重要的优化——常量折叠（Constant Folding）。

当我们写 String b = "a" + "b" 时，因为 "a" 和 "b" 都是字符串字面量常量，编译器在编译阶段就会将这个表达式优化为 String b = "ab"。也就是说，编译后的字节码中，这两行代码实际上是一样的。

由于都是字符串字面量，它们都会被放入字符串常量池中。根据字符串常量池的机制，相同内容的字符串只会存在一份，所以 a 和 b 实际上指向的是常量池中同一个 "ab" 对象。

因为 == 比较的是对象的引用地址，而 a 和 b 指向同一个对象，所以 a == b 返回 true。

需要注意的对比情况：如果涉及变量拼接，结果就不同了：

```java
String s1 = "a";
String s2 = "b";
String c = s1 + s2;  // 变量拼接，会在堆中创建新对象
String a = "ab";
System.out.println(a == c);  // false，因为 c 指向堆，a 指向常量池
```

这是因为变量拼接在编译期无法确定值，只能在运行时通过 StringBuilder 来完成，会创建新的对象。

---

### 4.5 String 有长度限制吗？是多少？

String 是有长度限制的，而且在编译期和运行期的限制是不一样的。

编译期限制：65534 字符

在编译期，字符串字面量的长度受到 class 文件格式的限制。在 class 文件的常量池中，字符串常量使用 CONSTANT_Utf8_info 结构存储，其中长度字段是 u2 类型，占 2 个字节，所以理论上最大值是 2^16-1 = 65535。如果你在代码中写一个超过这个长度的字符串字面量，编译器会直接报错："constant string too long"。

运行期限制：2^31-1 字符

在运行期，String 的长度限制取决于 String 类的实现。String 内部使用 char 数组（Java 9 之后是 byte 数组）来存储字符，而数组的最大长度是 Integer.MAX_VALUE，也就是 2^31-1 = 2147483647。

所以理论上运行时可以创建一个包含约 21 亿个字符的 String 对象，但实际上会受到 JVM 堆内存大小的限制。

---

### 4.6 为什么 JDK 9 中把 String 的 char[] 改成了 byte[]？

主要是为了节省内存空间，提升性能。

在 JDK 9 之前，String 内部使用 char[] 数组存储字符，每个 char 占用 2 个字节。但实际应用中，大部分字符串都是 Latin-1 字符（如英文、数字、常见符号），这些字符用 1 个字节就能表示，用 2 个字节存储造成了 50% 的内存浪费。

JDK 9 引入了**紧凑字符串（Compact Strings）**的概念，将 String 的内部存储从 char[] 改为 byte[]，并新增了一个 coder 字段来标识编码方式：

- **coder = LATIN1（0）**：表示字符串中所有字符都是 Latin-1 字符，每个字节存储一个字符，节省一半内存
- **coder = UTF16（1）**：表示字符串包含非 Latin-1 字符（如中文），每两个字节存储一个字符，和之前的 char[] 效果一样

举个例子：

```java
String s1 = "hello";  // 只需 5 字节，coder = LATIN1
String s2 = "你好";   // 需要 4 字节（2个字符×2字节），coder = UTF16
```

这个改进带来的好处：

1. 内存占用减少：对于纯 ASCII 或 Latin-1 字符串，内存占用减半
2. GC 压力降低：String 对象变小，垃圾回收效率提升
3. 缓存友好：更小的对象意味着更好的 CPU 缓存命中率

根据统计，大部分 Java 应用中的字符串都是 Latin-1 字符，所以这个优化对整体性能提升明显。这是一个典型的空间换时间的优化案例，通过增加一个 coder 字段的开销，换来了大量的内存节省。

---

### 4.7 String 是如何实现不可变的？

String 的不可变性是通过多层防护机制来保证的：

**第一，类被 final 修饰**。String 类被声明为 final，这意味着它不能被继承，防止子类重写方法来破坏不可变性。如果允许继承，子类可能会重写方法来修改内部状态。

**第二，内部数组被 final 修饰**。在 JDK 9 之前，String 内部使用 `private final char[] value` 存储字符；JDK 9 之后改为 `private final byte[] value`。final 关键字保证了数组引用不能被修改，即不能指向其他数组。

**第三，没有提供修改方法**。String 类没有提供任何可以修改内部数组内容的 public 方法，所有看起来"修改"字符串的方法（如 substring、concat、replace）实际上都是创建并返回新的 String 对象，原字符串保持不变。

**第四，内部数组私有且不暴露**。value 数组被声明为 private，外部无法直接访问。即使有返回字符数组的方法（如 toCharArray），也是返回数组的副本，而不是原数组的引用。

举个例子：

```java
String s1 = "hello";
String s2 = s1.concat(" world");  // 创建新对象
System.out.println(s1);  // 输出 "hello"，原字符串未改变
System.out.println(s2);  // 输出 "hello world"
```

需要注意的是，虽然 final 修饰了数组引用，但如果能获取到数组的引用，理论上还是可以修改数组内容的。所以 String 通过 private 访问控制和不提供修改方法，确保了外部无法获取和修改内部数组。

这种多层防护的设计，从类、字段、方法、访问控制等多个维度保证了 String 的不可变性。

---

